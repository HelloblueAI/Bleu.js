import { createLogger } from '../utils/logger';

export interface VulnerabilityConfig {
  scanInterval?: number;
  scanDepth?: 'basic' | 'deep';
  autoFix?: boolean;
  excludePatterns?: string[];
  customRules?: VulnerabilityRule[];
}

export interface VulnerabilityRule {
  id: string;
  name: string;
  description: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  category: string;
  pattern: RegExp;
  fix?: (code: string) => string;
}

export interface Vulnerability {
  ruleId: string;
  severity: VulnerabilityRule['severity'];
  location: {
    file: string;
    line: number;
    column: number;
  };
  description: string;
  code: string;
  suggestedFix?: string;
}

export interface ScanResult {
  vulnerabilities: Vulnerability[];
  summary: {
    total: number;
    bySeverity: Record<VulnerabilityRule['severity'], number>;
    fixableCount: number;
  };
  scanDuration: number;
  timestamp: Date;
}

export class VulnerabilityScanner {
  private logger = createLogger('VulnerabilityScanner');
  private config: Required<VulnerabilityConfig>;
  private rules: Map<string, VulnerabilityRule>;
  private scanInterval: NodeJS.Timeout | null;

  constructor(config: VulnerabilityConfig = {}) {
    this.config = {
      scanInterval: config.scanInterval ?? 3600000, // 1 hour
      scanDepth: config.scanDepth ?? 'basic',
      autoFix: config.autoFix ?? false,
      excludePatterns: config.excludePatterns ?? [
        'node_modules',
        'dist',
        'build',
        '.git'
      ],
      customRules: config.customRules ?? []
    };

    this.rules = new Map();
    this.scanInterval = null;
    this.initializeDefaultRules();
  }

  private initializeDefaultRules(): void {
    const defaultRules: VulnerabilityRule[] = [
      {
        id: 'insecure-crypto',
        name: 'Insecure Cryptographic Algorithm',
        description: 'Usage of weak or deprecated cryptographic algorithms',
        severity: 'high',
        category: 'security',
        pattern: /crypto\.createCipher|crypto\.createDecipher|MD5|SHA1/i,
        fix: (code: string) => {
          return code
            .replace(/crypto\.createCipher/g, 'crypto.createCipheriv')
            .replace(/crypto\.createDecipher/g, 'crypto.createDecipheriv')
            .replace(/MD5/g, 'SHA256')
            .replace(/SHA1/g, 'SHA256');
        }
      },
      {
        id: 'sql-injection',
        name: 'SQL Injection Vulnerability',
        description: 'Potential SQL injection vulnerability detected',
        severity: 'critical',
        category: 'security',
        pattern: /execute\s*\(\s*['"].*?\$\{.*?\}/i
      },
      {
        id: 'hardcoded-secrets',
        name: 'Hardcoded Secrets',
        description: 'Hardcoded credentials or secrets detected',
        severity: 'critical',
        category: 'security',
        pattern: /(password|secret|key|token|auth).*?=.*?['"][^'"]*['"]|const\s+(password|secret|key|token|auth)/i
      },
      {
        id: 'xss',
        name: 'Cross-Site Scripting',
        description: 'Potential XSS vulnerability detected',
        severity: 'high',
        category: 'security',
        pattern: /innerHTML|outerHTML|document\.write|eval\s*\(/i
      },
      {
        id: 'insecure-random',
        name: 'Insecure Random Number Generation',
        description: 'Usage of insecure random number generation',
        severity: 'medium',
        category: 'security',
        pattern: /Math\.random\(\)/i,
        fix: (code: string) => {
          return code.replace(
            /Math\.random\(\)/g,
            'crypto.randomBytes(32).toString("hex")'
          );
        }
      }
    ];

    // Add default rules
    for (const rule of defaultRules) {
      this.rules.set(rule.id, rule);
    }

    // Add custom rules
    for (const rule of this.config.customRules) {
      this.rules.set(rule.id, rule);
    }
  }

  async initialize(): Promise<void> {
    try {
      // Validate rules
      this.validateRules();

      // Start periodic scanning if interval is set
      if (this.config.scanInterval > 0) {
        this.scanInterval = setInterval(() => {
          this.scan().catch(error => {
            this.logger.error('Periodic scan failed:', error);
          });
        }, this.config.scanInterval);
      }

      this.logger.info('Vulnerability scanner initialized successfully');
    } catch (error) {
      this.logger.error('Failed to initialize vulnerability scanner:', error);
      throw error;
    }
  }

  private validateRules(): void {
    for (const [id, rule] of this.rules) {
      if (!rule.pattern || !(rule.pattern instanceof RegExp)) {
        throw new Error(`Invalid pattern for rule: ${id}`);
      }

      if (rule.fix && typeof rule.fix !== 'function') {
        throw new Error(`Invalid fix function for rule: ${id}`);
      }
    }
  }

  async scan(options: {
    files?: string[];
    rules?: string[];
    depth?: VulnerabilityConfig['scanDepth'];
  } = {}): Promise<ScanResult> {
    const startTime = Date.now();
    const vulnerabilities: Vulnerability[] = [];
    const summary = {
      total: 0,
      bySeverity: {
        low: 0,
        medium: 0,
        high: 0,
        critical: 0
      },
      fixableCount: 0
    };

    try {
      const files = options.files || await this.findFiles();
      const selectedRules = options.rules
        ? Array.from(this.rules.values()).filter(rule => options.rules!.includes(rule.id))
        : Array.from(this.rules.values());

      for (const file of files) {
        const code = await this.readFile(file);
        const fileVulnerabilities = await this.scanCode(file, code, selectedRules);
        vulnerabilities.push(...fileVulnerabilities);
      }

      // Update summary
      summary.total = vulnerabilities.length;
      for (const vuln of vulnerabilities) {
        summary.bySeverity[vuln.severity]++;
        if (this.rules.get(vuln.ruleId)?.fix) {
          summary.fixableCount++;
        }
      }

      const result: ScanResult = {
        vulnerabilities,
        summary,
        scanDuration: Date.now() - startTime,
        timestamp: new Date()
      };

      this.logger.info('Vulnerability scan completed:', result.summary);
      return result;
    } catch (error) {
      this.logger.error('Vulnerability scan failed:', error);
      throw error;
    }
  }

  private async findFiles(): Promise<string[]> {
    // This is a placeholder. In a real implementation, this would use
    // file system operations to find all relevant files to scan.
    return [];
  }

  private async readFile(file: string): Promise<string> {
    // This is a placeholder. In a real implementation, this would read
    // the file content from the file system.
    return '';
  }

  private async scanCode(
    file: string,
    code: string,
    rules: VulnerabilityRule[]
  ): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    const lines = code.split('\n');
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      
      for (const rule of rules) {
        const match = line.match(rule.pattern);
        if (match) {
          const vuln: Vulnerability = {
            ruleId: rule.id,
            severity: rule.severity,
            location: {
              file,
              line: i + 1,
              column: match.index || 0
            },
            description: rule.description,
            code: line.trim()
          };

          if (rule.fix) {
            vuln.suggestedFix = rule.fix(line);
          }

          vulnerabilities.push(vuln);
        }
      }
    }

    return vulnerabilities;
  }

  async fixVulnerabilities(
    vulnerabilities: Vulnerability[],
    options: { dryRun?: boolean } = {}
  ): Promise<{
    fixed: number;
    failed: number;
    changes: Array<{ file: string; original: string; fixed: string }>;
  }> {
    const result = {
      fixed: 0,
      failed: 0,
      changes: [] as Array<{ file: string; original: string; fixed: string }>
    };

    try {
      // Group vulnerabilities by file
      const byFile = new Map<string, Vulnerability[]>();
      for (const vuln of vulnerabilities) {
        if (!byFile.has(vuln.location.file)) {
          byFile.set(vuln.location.file, []);
        }
        byFile.get(vuln.location.file)!.push(vuln);
      }

      // Fix vulnerabilities in each file
      for (const [file, fileVulns] of byFile) {
        const code = await this.readFile(file);
        let fixedCode = code;

        for (const vuln of fileVulns) {
          const rule = this.rules.get(vuln.ruleId);
          if (rule?.fix) {
            try {
              const lines = fixedCode.split('\n');
              lines[vuln.location.line - 1] = rule.fix(lines[vuln.location.line - 1]);
              fixedCode = lines.join('\n');
              result.fixed++;
              result.changes.push({
                file,
                original: code,
                fixed: fixedCode
              });
            } catch (error) {
              this.logger.error(`Failed to fix vulnerability in ${file}:`, error);
              result.failed++;
            }
          }
        }

        if (!options.dryRun) {
          // In a real implementation, this would write the fixed code back to the file
        }
      }

      this.logger.info('Vulnerability fixes applied:', result);
      return result;
    } catch (error) {
      this.logger.error('Failed to fix vulnerabilities:', error);
      throw error;
    }
  }

  async addRule(rule: VulnerabilityRule): Promise<void> {
    try {
      if (this.rules.has(rule.id)) {
        throw new Error(`Rule with ID ${rule.id} already exists`);
      }

      if (!rule.pattern || !(rule.pattern instanceof RegExp)) {
        throw new Error('Invalid rule pattern');
      }

      this.rules.set(rule.id, rule);
      this.logger.info(`Added new vulnerability rule: ${rule.id}`);
    } catch (error) {
      this.logger.error('Failed to add vulnerability rule:', error);
      throw error;
    }
  }

  async removeRule(ruleId: string): Promise<void> {
    try {
      if (!this.rules.has(ruleId)) {
        throw new Error(`Rule with ID ${ruleId} not found`);
      }

      this.rules.delete(ruleId);
      this.logger.info(`Removed vulnerability rule: ${ruleId}`);
    } catch (error) {
      this.logger.error('Failed to remove vulnerability rule:', error);
      throw error;
    }
  }

  async dispose(): Promise<void> {
    try {
      if (this.scanInterval) {
        clearInterval(this.scanInterval);
        this.scanInterval = null;
      }

      this.rules.clear();
      this.logger.info('Vulnerability scanner disposed successfully');
    } catch (error) {
      this.logger.error('Failed to dispose vulnerability scanner:', error);
      throw error;
    }
  }
} 